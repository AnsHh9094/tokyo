<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#060010">
    <title>Tokyo AI</title>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@200;300;400;500;600&display=swap" rel="stylesheet">
    <style>
        *,
        *::before,
        *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            scroll-behavior: smooth;
        }

        :root {
            --bg: #060010;
            --accent: #B19EEF;
            --text: #e0e0f0;
            --text-dim: #607080;
        }

        body {
            background: var(--bg);
            color: var(--text);
            font-family: 'Outfit', sans-serif;
            height: 100dvh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            user-select: none;
            position: relative;
        }

        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê GHOST CURSOR ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
        .ghost-cursor {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 0;
        }

        .ghost-cursor canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê HEADER ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 18px 24px;
            z-index: 10;
            background: linear-gradient(180deg, rgba(6, 0, 16, 0.7), transparent);
        }

        .header h1 {
            font-size: 1.15rem;
            font-weight: 500;
            letter-spacing: 4px;
            color: rgba(177, 158, 239, 0.8);
        }

        .status-dot {
            width: 7px;
            height: 7px;
            border-radius: 50%;
            background: #B19EEF;
            box-shadow: 0 0 8px rgba(177, 158, 239, 0.6);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 0.4;
            }

            50% {
                opacity: 1;
            }
        }

        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê ORB ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
        #orb-canvas {
            width: 100%;
            height: 180px;
            flex-shrink: 0;
            z-index: 1;
        }

        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê CHAT ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
        .chat-area {
            flex: 1;
            overflow-y: auto;
            scroll-behavior: smooth;
            padding: 0 24px 100px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            scrollbar-width: none;
            z-index: 2;
        }

        .msg {
            max-width: 80%;
            padding: 10px 16px;
            border-radius: 14px;
            font-size: 0.95rem;
            line-height: 1.5;
            animation: fadeIn 0.3s ease;
        }

        .msg.user {
            align-self: flex-end;
            background: rgba(177, 158, 239, 0.1);
            color: #d0c0ff;
        }

        .msg.ai {
            align-self: flex-start;
            background: rgba(255, 255, 255, 0.03);
            color: #c0c0d0;
        }

        .msg.system {
            align-self: center;
            background: none;
            border: none;
            color: var(--text-dim);
            font-size: 0.75rem;
            letter-spacing: 1px;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(6px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê INPUT ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
        .input-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 16px 24px 28px;
            display: flex;
            align-items: center;
            gap: 14px;
            background: linear-gradient(0deg, var(--bg) 60%, transparent);
            z-index: 10;
        }

        .mic-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(177, 158, 239, 0.08);
            border: 1px solid rgba(177, 158, 239, 0.15);
            color: var(--accent);
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .mic-btn:active {
            transform: scale(0.9);
        }

        .mic-btn.active {
            background: rgba(255, 80, 80, 0.1);
            border-color: rgba(255, 80, 80, 0.3);
            color: #ff5050;
            box-shadow: 0 0 20px rgba(255, 80, 80, 0.2);
        }

        input {
            flex: 1;
            background: transparent;
            border: none;
            border-bottom: 1px solid rgba(177, 158, 239, 0.1);
            color: #fff;
            font-size: 1rem;
            font-family: inherit;
            padding: 10px 4px;
            outline: none;
        }

        input::placeholder {
            color: var(--text-dim);
        }

        input:focus {
            border-bottom-color: rgba(177, 158, 239, 0.3);
        }

        .send-btn {
            background: none;
            border: none;
            color: rgba(177, 158, 239, 0.6);
            font-size: 0.85rem;
            font-weight: 500;
            letter-spacing: 1px;
            cursor: pointer;
        }

        .send-btn:hover {
            color: var(--accent);
        }
    </style>
</head>

<body>

    <!-- Ghost Cursor Layer -->
    <div class="ghost-cursor" id="ghostHost"></div>

    <!-- Header -->
    <div class="header">
        <h1>TOKYO</h1>
        <div class="status-dot" id="statusDot"></div>
    </div>

    <!-- Orb -->
    <canvas id="orb-canvas"></canvas>

    <!-- Chat -->
    <div class="chat-area" id="chat">
        <div class="msg system">Ready</div>
    </div>

    <!-- Input -->
    <div class="input-bar">
        <div class="mic-btn" id="micBtn" onclick="toggleMic()">üéô</div>
        <input type="text" id="textInput" placeholder="Ask anything..." autocomplete="off">
        <button class="send-btn" onclick="sendText()">SEND</button>
    </div>

    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê APP LOGIC ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
    <script>
        const chat = document.getElementById('chat');
        const input = document.getElementById('textInput');
        const micBtn = document.getElementById('micBtn');

        function addMsg(text, type = 'ai') {
            const d = document.createElement('div');
            d.className = `msg ${type}`;
            d.textContent = text;
            chat.appendChild(d);
            chat.scrollTop = chat.scrollHeight;
        }

        async function cmd(text) {
            if (!text.trim()) return;
            addMsg(text, 'user');
            try {
                const res = await fetch('/command', {
                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text })
                });
                const data = await res.json();
                if (data.response) addMsg(data.response, 'ai');
            } catch (e) { addMsg('Connection error', 'system'); }
        }

        function sendText() { const t = input.value.trim(); if (t) { cmd(t); input.value = ''; } }
        input.addEventListener('keydown', e => { if (e.key === 'Enter') sendText(); });

        // Voice
        let recognition = null, isListening = false;
        if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
            const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SR();
            recognition.continuous = false; recognition.interimResults = false;
            recognition.onstart = () => { isListening = true; micBtn.classList.add('active'); };
            recognition.onend = () => { isListening = false; micBtn.classList.remove('active'); };
            recognition.onresult = e => cmd(e.results[0][0].transcript);
        }
        function toggleMic() { if (recognition) isListening ? recognition.stop() : recognition.start(); }

        // SSE
        function connectSSE() {
            const es = new EventSource('/stream');
            es.onmessage = e => {
                try { const d = JSON.parse(e.data); if (d.type === 'response') addMsg(d.text, 'ai'); } catch (err) { }
            };
            es.onerror = () => { es.close(); setTimeout(connectSSE, 3000); };
        }
        connectSSE();

        // Orb (lightweight canvas)
        const cvs = document.getElementById('orb-canvas');
        const ctx = cvs.getContext('2d');
        let W, H;
        function resizeOrb() {
            W = cvs.clientWidth * devicePixelRatio;
            H = cvs.clientHeight * devicePixelRatio;
            cvs.width = W; cvs.height = H;
        }
        window.addEventListener('resize', resizeOrb); resizeOrb();
        (function drawOrb() {
            requestAnimationFrame(drawOrb);
            ctx.clearRect(0, 0, W, H);
            const cx = W / 2, cy = H / 2;
            const t = Date.now() * 0.001;
            const r = Math.min(W, H) * 0.12 + Math.sin(t * 1.5) * 3;

            // Soft glow
            const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, r * 4);
            g.addColorStop(0, 'rgba(177, 158, 239, 0.15)');
            g.addColorStop(0.5, 'rgba(100, 80, 180, 0.05)');
            g.addColorStop(1, 'transparent');
            ctx.fillStyle = g;
            ctx.beginPath(); ctx.arc(cx, cy, r * 4, 0, Math.PI * 2); ctx.fill();

            // Core
            const cg = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
            cg.addColorStop(0, '#e0d0ff');
            cg.addColorStop(0.5, '#B19EEF');
            cg.addColorStop(1, '#4030a0');
            ctx.fillStyle = cg;
            ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI * 2); ctx.fill();

            // Ring
            ctx.strokeStyle = 'rgba(177, 158, 239, 0.2)';
            ctx.lineWidth = 1;
            ctx.beginPath(); ctx.ellipse(cx, cy, r * 2.5, r * 0.7, t * 0.3, 0, Math.PI * 2); ctx.stroke();

            // Letter
            ctx.fillStyle = '#fff';
            ctx.font = `500 ${r * 0.7}px Outfit`;
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText('T', cx, cy);
        })();
    </script>

    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê GHOST CURSOR ‚Äî Faithful ReactBits port ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
    <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

        const host = document.getElementById('ghostHost');
        if (!host) throw 'no host';

        // ‚îÄ‚îÄ Config (ReactBits defaults) ‚îÄ‚îÄ
        const TRAIL = 50;
        const INERTIA = 0.5;
        const GRAIN = 0.05;
        const BLOOM_STR = 0.1;
        const BLOOM_RAD = 1.0;
        const BLOOM_THR = 0.025;
        const BRIGHTNESS = 2;
        const COLOR = new THREE.Color('#B19EEF');
        const MAX_DPR = 0.5;
        const FADE_DELAY = 1000;
        const FADE_DUR = 1500;

        // ‚îÄ‚îÄ Renderer ‚îÄ‚îÄ
        const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        const renderer = new THREE.WebGLRenderer({
            antialias: !isTouch, alpha: true, depth: false, stencil: false,
            powerPreference: isTouch ? 'low-power' : 'high-performance',
            premultipliedAlpha: false, preserveDrawingBuffer: false
        });
        renderer.setClearColor(0x000000, 0);
        renderer.domElement.style.pointerEvents = 'none';
        renderer.domElement.style.mixBlendMode = 'screen';
        host.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

        // ‚îÄ‚îÄ Trail buffer ‚îÄ‚îÄ
        const trailBuf = Array.from({ length: TRAIL }, () => new THREE.Vector2(0.5, 0.5));
        let head = 0;

        // ‚îÄ‚îÄ Vertex shader ‚îÄ‚îÄ
        const vertSrc = `
      varying vec2 vUv;
      void main() { vUv = uv; gl_Position = vec4(position, 1.0); }
    `;

        // ‚îÄ‚îÄ Fragment shader (EXACT ReactBits) ‚îÄ‚îÄ
        const fragSrc = `
      #define MAX_TRAIL_LENGTH ${TRAIL}
      uniform float iTime;
      uniform vec3  iResolution;
      uniform vec2  iMouse;
      uniform vec2  iPrevMouse[MAX_TRAIL_LENGTH];
      uniform float iOpacity;
      uniform float iScale;
      uniform vec3  iBaseColor;
      uniform float iBrightness;
      uniform float iEdgeIntensity;
      varying vec2  vUv;

      float hash(vec2 p){ return fract(sin(dot(p,vec2(127.1,311.7))) * 43758.5453123); }
      float noise(vec2 p){
        vec2 i = floor(p), f = fract(p);
        f *= f * (3. - 2. * f);
        return mix(mix(hash(i + vec2(0.,0.)), hash(i + vec2(1.,0.)), f.x),
                   mix(hash(i + vec2(0.,1.)), hash(i + vec2(1.,1.)), f.x), f.y);
      }
      float fbm(vec2 p){
        float v = 0.0;
        float a = 0.5;
        mat2 m = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));
        for(int i=0;i<5;i++){
          v += a * noise(p);
          p = m * p * 2.0;
          a *= 0.5;
        }
        return v;
      }
      vec3 tint1(vec3 base){ return mix(base, vec3(1.0), 0.15); }
      vec3 tint2(vec3 base){ return mix(base, vec3(0.8, 0.9, 1.0), 0.25); }

      vec4 blob(vec2 p, vec2 mousePos, float intensity, float activity) {
        vec2 q = vec2(fbm(p * iScale + iTime * 0.1), fbm(p * iScale + vec2(5.2,1.3) + iTime * 0.1));
        vec2 r = vec2(fbm(p * iScale + q * 1.5 + iTime * 0.15), fbm(p * iScale + q * 1.5 + vec2(8.3,2.8) + iTime * 0.15));

        float smoke = fbm(p * iScale + r * 0.8);
        float radius = 0.5 + 0.3 * (1.0 / iScale);
        float distFactor = 1.0 - smoothstep(0.0, radius * activity, length(p - mousePos));
        float alpha = pow(smoke, 2.5) * distFactor;

        vec3 c1 = tint1(iBaseColor);
        vec3 c2 = tint2(iBaseColor);
        vec3 color = mix(c1, c2, sin(iTime * 0.5) * 0.5 + 0.5);

        return vec4(color * alpha * intensity, alpha * intensity);
      }

      void main() {
        vec2 uv = (gl_FragCoord.xy / iResolution.xy * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);
        vec2 mouse = (iMouse * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);

        vec3 colorAcc = vec3(0.0);
        float alphaAcc = 0.0;

        vec4 b = blob(uv, mouse, 1.0, iOpacity);
        colorAcc += b.rgb;
        alphaAcc += b.a;

        for (int i = 0; i < MAX_TRAIL_LENGTH; i++) {
          vec2 pm = (iPrevMouse[i] * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);
          float t = 1.0 - float(i) / float(MAX_TRAIL_LENGTH);
          t = pow(t, 2.0);
          if (t > 0.01) {
            vec4 bt = blob(uv, pm, t * 0.8, iOpacity);
            colorAcc += bt.rgb;
            alphaAcc += bt.a;
          }
        }

        colorAcc *= iBrightness;

        vec2 uv01 = gl_FragCoord.xy / iResolution.xy;
        float edgeDist = min(min(uv01.x, 1.0 - uv01.x), min(uv01.y, 1.0 - uv01.y));
        float distFromEdge = clamp(edgeDist * 2.0, 0.0, 1.0);
        float k = clamp(iEdgeIntensity, 0.0, 1.0);
        float edgeMask = mix(1.0 - k, 1.0, distFromEdge);

        float outAlpha = clamp(alphaAcc * iOpacity * edgeMask, 0.0, 1.0);
        gl_FragColor = vec4(colorAcc, outAlpha);
      }
    `;

        // ‚îÄ‚îÄ Film Grain Shader ‚îÄ‚îÄ
        const FilmGrainShader = {
            uniforms: {
                tDiffuse: { value: null },
                iTime: { value: 0 },
                intensity: { value: GRAIN }
            },
            vertexShader: `
        varying vec2 vUv;
        void main(){ vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }
      `,
            fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float iTime;
        uniform float intensity;
        varying vec2 vUv;
        float hash1(float n){ return fract(sin(n)*43758.5453); }
        void main(){
          vec4 color = texture2D(tDiffuse, vUv);
          float n = hash1(vUv.x*1000.0 + vUv.y*2000.0 + iTime) * 2.0 - 1.0;
          color.rgb += n * intensity * color.rgb;
          gl_FragColor = color;
        }
      `
        };

        // ‚îÄ‚îÄ Unpremultiply Pass ‚îÄ‚îÄ
        const UnpremultiplyShader = {
            uniforms: { tDiffuse: { value: null } },
            vertexShader: `
        varying vec2 vUv;
        void main(){ vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }
      `,
            fragmentShader: `
        uniform sampler2D tDiffuse;
        varying vec2 vUv;
        void main(){
          vec4 c = texture2D(tDiffuse, vUv);
          float a = max(c.a, 1e-5);
          vec3 straight = c.rgb / a;
          gl_FragColor = vec4(clamp(straight, 0.0, 1.0), c.a);
        }
      `
        };

        // ‚îÄ‚îÄ Material ‚îÄ‚îÄ
        function calcScale() {
            const base = 600;
            const current = Math.min(Math.max(1, window.innerWidth), Math.max(1, window.innerHeight));
            return Math.max(0.5, Math.min(2.0, current / base));
        }

        const material = new THREE.ShaderMaterial({
            defines: { MAX_TRAIL_LENGTH: TRAIL },
            uniforms: {
                iTime: { value: 0 },
                iResolution: { value: new THREE.Vector3(1, 1, 1) },
                iMouse: { value: new THREE.Vector2(0.5, 0.5) },
                iPrevMouse: { value: trailBuf.map(v => v.clone()) },
                iOpacity: { value: 1.0 },
                iScale: { value: calcScale() },
                iBaseColor: { value: new THREE.Vector3(COLOR.r, COLOR.g, COLOR.b) },
                iBrightness: { value: BRIGHTNESS },
                iEdgeIntensity: { value: 0 }
            },
            vertexShader: vertSrc,
            fragmentShader: fragSrc,
            transparent: true,
            depthTest: false,
            depthWrite: false
        });

        scene.add(new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material));

        // ‚îÄ‚îÄ Post-processing ‚îÄ‚îÄ
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));

        const bloomPass = new UnrealBloomPass(new THREE.Vector2(1, 1), BLOOM_STR, BLOOM_RAD, BLOOM_THR);
        composer.addPass(bloomPass);

        const filmPass = new ShaderPass(FilmGrainShader);
        composer.addPass(filmPass);

        const unpremPass = new ShaderPass(UnpremultiplyShader);
        composer.addPass(unpremPass);

        // ‚îÄ‚îÄ Resize ‚îÄ‚îÄ
        const pixelBudget = isTouch ? 0.9e6 : 1.3e6;
        function onResize() {
            const cssW = Math.max(1, window.innerWidth);
            const cssH = Math.max(1, window.innerHeight);
            const dpr = Math.min(window.devicePixelRatio || 1, MAX_DPR);
            const need = cssW * cssH * dpr * dpr;
            const scale = need <= pixelBudget ? 1 : Math.max(0.5, Math.min(1, Math.sqrt(pixelBudget / Math.max(1, need))));
            const pr = dpr * scale;

            renderer.setPixelRatio(pr);
            renderer.setSize(cssW, cssH, false);
            composer.setSize(cssW, cssH);

            const wpx = Math.max(1, Math.floor(cssW * pr));
            const hpx = Math.max(1, Math.floor(cssH * pr));
            material.uniforms.iResolution.value.set(wpx, hpx, 1);
            material.uniforms.iScale.value = calcScale();
            bloomPass.setSize(wpx, hpx);
        }
        onResize();
        window.addEventListener('resize', onResize);

        // ‚îÄ‚îÄ Pointer ‚îÄ‚îÄ
        const mouse = new THREE.Vector2(0.5, 0.5);
        const velocity = new THREE.Vector2(0, 0);
        let pointerActive = false;
        let lastMoveTime = performance.now();
        let fadeOpacity = 1.0;
        let running = true;

        document.addEventListener('pointermove', e => {
            const x = e.clientX / window.innerWidth;
            const y = 1 - e.clientY / window.innerHeight;
            mouse.set(
                THREE.MathUtils.clamp(x, 0, 1),
                THREE.MathUtils.clamp(y, 0, 1)
            );
            pointerActive = true;
            lastMoveTime = performance.now();
            ensureLoop();
        }, { passive: true });

        document.addEventListener('pointerenter', () => { pointerActive = true; ensureLoop(); }, { passive: true });
        document.addEventListener('pointerleave', () => { pointerActive = false; lastMoveTime = performance.now(); ensureLoop(); }, { passive: true });

        function ensureLoop() {
            if (!running) {
                running = true;
                requestAnimationFrame(animate);
            }
        }

        // ‚îÄ‚îÄ Animate ‚îÄ‚îÄ
        const startTime = performance.now();

        function animate() {
            const now = performance.now();
            const t = (now - startTime) / 1000;

            if (pointerActive) {
                velocity.set(
                    mouse.x - material.uniforms.iMouse.value.x,
                    mouse.y - material.uniforms.iMouse.value.y
                );
                material.uniforms.iMouse.value.copy(mouse);
                fadeOpacity = 1.0;
            } else {
                velocity.multiplyScalar(INERTIA);
                if (velocity.lengthSq() > 1e-6) {
                    material.uniforms.iMouse.value.add(velocity);
                }
                const dt = now - lastMoveTime;
                if (dt > FADE_DELAY) {
                    const k = Math.min(1, (dt - FADE_DELAY) / FADE_DUR);
                    fadeOpacity = Math.max(0, 1 - k);
                }
            }

            // Update trail
            head = (head + 1) % TRAIL;
            trailBuf[head].copy(material.uniforms.iMouse.value);
            const arr = material.uniforms.iPrevMouse.value;
            for (let i = 0; i < TRAIL; i++) {
                const srcIdx = (head - i + TRAIL) % TRAIL;
                arr[i].copy(trailBuf[srcIdx]);
            }

            material.uniforms.iOpacity.value = fadeOpacity;
            material.uniforms.iTime.value = t;

            if (filmPass.uniforms?.iTime) {
                filmPass.uniforms.iTime.value = t;
            }

            composer.render();

            // Pause when fully faded
            if (!pointerActive && fadeOpacity <= 0.001) {
                running = false;
                return;
            }

            requestAnimationFrame(animate);
        }

        // Start
        ensureLoop();
    </script>
</body>

</html>